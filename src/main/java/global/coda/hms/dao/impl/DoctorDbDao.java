package global.coda.hms.dao.impl;


import global.coda.hms.config.MysqlConnection;
import global.coda.hms.constant.applicationconstant.daoconstants.DoctorDaoConstants;
import global.coda.hms.constant.dbconstant.MysqlQueries;
import global.coda.hms.model.Doctor;
import global.coda.hms.model.Patient;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.ResourceBundle;


/**
 * The type Doctor db dao.
 */
public class DoctorDbDao {

    /**
     * The Logger.
     */
    private static Logger LOGGER= LogManager.getLogger(DoctorDbDao.class);

    private static final ResourceBundle LOCAL_MESSAGES_BUNDLE = ResourceBundle.getBundle("messages",
            Locale.getDefault());

    /**
     * Create boolean.
     *
     * @param doctor the doctor
     * @return boolean
     * @throws Exception the exception
     */
    public static Boolean create(Doctor doctor) throws Exception {
        LOGGER.traceEntry(doctor.toString());
        MysqlConnection connection = new MysqlConnection();
        Connection sqlConnection = connection.getConnection();
        String queryDoctor = LOCAL_MESSAGES_BUNDLE.getString(MysqlQueries.CREATE_DOCTOR_T_DOCTOR);
        String queryUser = LOCAL_MESSAGES_BUNDLE.getString(MysqlQueries.CREATE_DOCTOR_T_USER);
        //t_user table contents
        String username = doctor.getUsername();
        String email = doctor.getEmail();
        String password = doctor.getPassword();
        int roleId = 2;
        //t_doctor Contents
        String specialist = doctor.getSpecialist();


        PreparedStatement statement = sqlConnection.prepareStatement(queryUser, Statement.RETURN_GENERATED_KEYS);
        statement.setString(DoctorDaoConstants.ONE, username);
        statement.setString(DoctorDaoConstants.TWO, email);
        statement.setString(DoctorDaoConstants.THREE, password);
        statement.setInt(DoctorDaoConstants.FOUR, roleId);

        statement.executeUpdate();
        //get the Autogenerated Key
        ResultSet privateKeys = statement.getGeneratedKeys();
        if (privateKeys.next()) {
            doctor.setUserId(privateKeys.getInt(1));
        }


        int userId = doctor.getUserId();


        statement = sqlConnection.prepareStatement(queryDoctor);
        statement.setString(1, specialist);
        statement.setInt(2, userId);
        int noOfRowsAffected = statement.executeUpdate();
        if (noOfRowsAffected != 1) {
            sqlConnection.rollback();
        }
        connection.closeConnection();
        LOGGER.traceExit(true);
        return true;

    }

    /**
     * Read doctor.
     *
     * @param userId the id
     * @return doctor
     * @throws Exception the exception
     */
    public static Doctor read(int userId) throws Exception {
        LOGGER.traceEntry(String.valueOf(userId));
        MysqlConnection connection = new MysqlConnection();

        Connection sqlConnection = connection.getConnection();
        Doctor doctor = new Doctor();

        String readDoctorQuery = LOCAL_MESSAGES_BUNDLE.getString(MysqlQueries.READ_DOCTOR_T_USER__JOIN_T_DOCTOR);
        PreparedStatement statement = sqlConnection.prepareStatement(readDoctorQuery);
        statement.setInt(1, userId);
        statement.setInt(2, 1);
        statement.setInt(DoctorDaoConstants.THREE, 1);


        ResultSet resultSet = statement.executeQuery();

        while (resultSet.next()) {
            doctor.setUserId(resultSet.getInt(1));
            doctor.setUsername(resultSet.getString(2));
            doctor.setEmail(resultSet.getString(DoctorDaoConstants.THREE));
            doctor.setPassword(resultSet.getString(DoctorDaoConstants.FOUR));
            doctor.setRoleId(resultSet.getInt(DoctorDaoConstants.FIVE));
            doctor.setSpecialist(resultSet.getString(DoctorDaoConstants.SIX));

        }
        connection.closeConnection();
        LOGGER.traceExit(doctor);
        return doctor;

    }

    /**
     * ReadALL.
     *
     * @return list
     * @throws Exception the exception
     */
    public static List<Doctor> readAll() throws Exception {
        LOGGER.traceEntry();
        List<Doctor> doctorList = new ArrayList<>();
        MysqlConnection connection = new MysqlConnection();

        Connection sqlConnection = connection.getConnection();

        PreparedStatement statement = sqlConnection.prepareStatement("select pk_user_id,username,email,password,fk_role_id,specialist from t_user join t_doctor on t_user.pk_user_id = t_doctor.fk_user_id  where t_user.is_active=? and t_doctor.is_active=?");
        statement.setInt(1, 1);
        statement.setInt(2, 1);

        ResultSet resultSet = statement.executeQuery();
        while (resultSet.next()) {
            Doctor doctor = new Doctor();
            doctor.setUserId(resultSet.getInt(1));
            doctor.setUsername(resultSet.getString(2));
            doctor.setEmail(resultSet.getString(DoctorDaoConstants.THREE));
            doctor.setPassword(resultSet.getString(DoctorDaoConstants.FOUR));
            doctor.setRoleId(resultSet.getInt(DoctorDaoConstants.FIVE));
            doctor.setSpecialist(resultSet.getString(DoctorDaoConstants.SIX));
            doctorList.add(doctor);
        }
        connection.closeConnection();

        LOGGER.traceExit(doctorList);
        return doctorList;
    }

    /**
     * Readd.
     *
     * @return list
     * @throws Exception the exception
     */
    public static List<Doctor> readAllWithMaskedDetails() throws Exception {
        LOGGER.traceEntry();
        List<Doctor> doctorList = new ArrayList<>();
        MysqlConnection connection = new MysqlConnection();

        Connection sqlConnection = connection.getConnection();

        PreparedStatement statement = sqlConnection.prepareStatement("select username,specialist from t_user join t_doctor on t_user.pk_user_id = t_doctor.fk_user_id  where t_user.is_active=? and t_doctor.is_active=?");
        statement.setInt(1, 1);
        statement.setInt(2, 1);

        ResultSet resultSet = statement.executeQuery();
        while (resultSet.next()) {
            Doctor doctor = new Doctor();
            doctor.setUsername(resultSet.getString(1));

            doctor.setSpecialist(resultSet.getString(2));
            doctorList.add(doctor);
        }
        connection.closeConnection();

        LOGGER.traceExit(doctorList);
        return doctorList;
    }

    /**
     * Update.
     *
     * @param doctor the doctor
     * @return boolean
     * @throws Exception the exception
     */
    public static Boolean update(Doctor doctor) throws Exception {
        LOGGER.traceEntry(doctor.toString());
        MysqlConnection connection = new MysqlConnection();

        Connection sqlConnection = connection.getConnection();
        //t_user table contents
        String username = doctor.getUsername();
        String email = doctor.getEmail();
        String password = doctor.getPassword();
        int userId = doctor.getUserId();
        //t_doctor Contents
        String specialization = doctor.getSpecialist();
        String userQuery = LOCAL_MESSAGES_BUNDLE.getString(MysqlQueries.UPDATE_DOCTOR_T_USER);
        String doctorQuery = LOCAL_MESSAGES_BUNDLE.getString(MysqlQueries.UPDATE_DOCTOR_T_DOCTOR);


        PreparedStatement statement = sqlConnection.prepareStatement(userQuery);
        statement.setString(1, username);
        statement.setString(2, email);
        statement.setString(DoctorDaoConstants.THREE, password);
        statement.setInt(DoctorDaoConstants.FOUR, userId);
        statement.setInt(DoctorDaoConstants.FIVE, 1);
        statement.executeUpdate();
        statement = sqlConnection.prepareStatement(doctorQuery);
        statement.setString(1, specialization);
        statement.setInt(2, userId);
        statement.setInt(DoctorDaoConstants.THREE, 1);
        int noOfRowsAffected = statement.executeUpdate();
        if (noOfRowsAffected != 1) {
            sqlConnection.rollback();
        }

        connection.closeConnection();
        LOGGER.traceExit(true);
        return true;
    }

    /**
     * Delete.
     *
     * @param userId the user id
     * @return boolean
     * @throws Exception the exception
     */
    public static Boolean delete(int userId) throws Exception {
        LOGGER.traceEntry(String.valueOf(userId));

        MysqlConnection connection = new MysqlConnection();

        Connection sqlConnection = connection.getConnection();
        String userQuery = LOCAL_MESSAGES_BUNDLE.getString(MysqlQueries.DELETE_DOCTOR_T_USER);
        String doctorQuery = LOCAL_MESSAGES_BUNDLE.getString(MysqlQueries.DELETE_DOCTOR_T_DOCTOR);

        PreparedStatement statement = sqlConnection.prepareStatement(userQuery);
        statement.setInt(1, 0);
        statement.setInt(2, userId);
        statement.executeUpdate();

        statement = sqlConnection.prepareStatement(doctorQuery);
        statement.setInt(1, 0);
        statement.setInt(2, userId);
        statement.executeUpdate();


        connection.closeConnection();
        LOGGER.info(LOCAL_MESSAGES_BUNDLE.getString(DoctorDaoConstants.DOCTOR_DELETE_IN_DB));

        return true;

    }

    /**
     * Read all doctor id list.
     *
     * @return list
     * @throws Exception the exception
     */
    public static List<Integer> readAllDoctorId() throws Exception {
        LOGGER.traceEntry();
        List<Integer> doctorIdList = new ArrayList<>();
        MysqlConnection connection = new MysqlConnection();

        Connection sqlConnection = connection.getConnection();

        PreparedStatement statement = sqlConnection.prepareStatement("select pk_user_id from t_user where fk_role_id=? and is_active=?");
        statement.setInt(1, 2);
        statement.setInt(2, 1);

        ResultSet resultSet = statement.executeQuery();
        while (resultSet.next()) {
            doctorIdList.add(resultSet.getInt(1));
        }
        connection.closeConnection();

        LOGGER.traceExit(doctorIdList);
        return doctorIdList;
    }

    /**
     * Read all doctors patients map.
     *
     * @return the map
     * @throws Exception the exception
     */
    public static Map<Integer, Doctor> readAllDoctorsPatients() throws Exception {
        LOGGER.traceEntry();
        Map<Integer, Doctor> doctorMap = new HashMap<Integer, Doctor>();
        MysqlConnection connection = new MysqlConnection();

        Connection sqlConnection = connection.getConnection();

        PreparedStatement statement = sqlConnection.prepareStatement("select t_patient_has_doctor.fk_doctor_id, pk_user_id,username,email,password,fk_role_id,age,area,city,state from t_user join t_patient on t_user.pk_user_id = t_patient.fk_user_id join t_patient_has_doctor on t_patient_has_doctor.fk_patient_id = t_user.pk_user_id  where t_user.is_active =? and t_patient.is_active=? and t_patient_has_doctor.is_active=?");
        statement.setInt(1, 1);
        statement.setInt(2, 1);
        statement.setInt(DoctorDaoConstants.THREE, 1);


        ResultSet resultSet = statement.executeQuery();
        while (resultSet.next()) {
            List<Patient> patientList;
            Doctor doctor = new Doctor();
            Patient patient = new Patient();

            doctor.setUserId(resultSet.getInt(1));
            patient.setUserId(resultSet.getInt(2));
            patient.setUsername(resultSet.getString(DoctorDaoConstants.THREE));
            patient.setEmail(resultSet.getString(DoctorDaoConstants.FOUR));
            patient.setPassword(resultSet.getString(DoctorDaoConstants.FIVE));
            patient.setRoleId(resultSet.getInt(DoctorDaoConstants.SIX));
            patient.setAge(resultSet.getInt(DoctorDaoConstants.SEVEN));
            patient.setArea(resultSet.getString(DoctorDaoConstants.EIGHT));
            patient.setCity(resultSet.getString(DoctorDaoConstants.NINE));
            patient.setState(resultSet.getString(DoctorDaoConstants.TEN));
            if (!doctorMap.containsKey(doctor.getUserId())) {
                patientList = new ArrayList<>();
                patientList.add(patient);
                doctor.setPatientList(patientList);
                doctorMap.put(doctor.getUserId(), doctor);

            } else {
                doctor = doctorMap.get(doctor.getUserId());
                patientList = doctor.getPatientList();
                patientList.add(patient);
                // doctor.setPatientList(patientList);
                // doctorMap.put(doctor.getUserId(),doctor);
            }
        }
        LOGGER.traceExit(doctorMap);
        connection.closeConnection();


        return doctorMap;
    }
}
